<?php
/**
 * 05/12/2011 BBX
 * Rewrinting script to use database connection, models and clear messages
 * Previous fixes are kept.
 * Done while fixing bug 24843
 * 
 * 02/01/2012 BBX
 * BZ 25230 : adding 3d parameters "true" to function displayInDemon 
 * in order to write directly into html log file

 *	03/10/2012 ACS BZ 29105 display of warning during backup processus
 */
set_time_limit(0);

include_once(dirname(__FILE__)."/../php/environnement_liens.php");
include_once(REP_PHYSIQUE_NIVEAU_0 . "class/DataBaseConnection.class.php");
include_once(REP_PHYSIQUE_NIVEAU_0 . "php/edw_function.php");
include_once(REP_PHYSIQUE_NIVEAU_0 . "class/libMail.class.php");

// CONSTANTS
define('EMAIL_SUPPORT','support@astellia.com');

// Functions

/**
 * Converts bytes to Mb
 * @param integer $size
 * @return integer 
 */
function bytesToMegabytes($size)
{
    return round(abs($size/(1024*1024)));
}

// Database Information
// Connexion à la base, et récupération du nom et du login de la base de données (YNE 19/07/10 : bug 16785)
// 07/11/2011 BBX BZ 24533 : remplacement new DataBaseConnection() par Database::getConnection()
$db     = Database::getConnection();
$DBName = $db->getDbName();
$AUser  = $db->getDbLogin();
$APass  = $db->getDbPassword();

// Backup information
$module     = __T("A_TRACELOG_MODULE_LABEL_DUMP_DATABASE");
$today      = date("Ymd");
$backupFile = "dump_database_" . $DBName . "_" . $today . ".dump.gz";
$backupPath = get_sys_global_parameters("backup_database");

// 26/02/2010 NSE bz 9050
// on vérifie qu'on a assez d'espace pour effectuer la sauvegarde.
// observation : taille d'un dump = taille de la base / 8 à 27, visiblement en fonction de taille de la base 9 pour une base de 66Go, 26 pour une de 3Go
// on choisit un rapport de 1/2
// 26/11/2010 NSE bz 19450 : on prend le même rapport (1/8) que dans le script de backup qui semble meilleur
$multiplier = 1/8;

// Test du répertoire de sauvegarde
if(!is_dir($backupPath))
{
    // 03/04/2012 BBX
    // BZ 26520 : Tentative de création du répertoire
    if(!@mkdir($backupPath, 0777, true))
    {
        $message = __T('A_PROCESS_BACKUP_DB_FAILED') . " " . __T('A_PROCESS_BACKUP_DB_WRONG_DIR',$backupPath);
        displayInDemon($message,"alert",true);
        sys_log_ast("Critical", "Trending&Aggregation", $module, $message, "support_1", "");
        return;
    }
}

// 03/04/2012 BBX
// BZ 26520 : Traitement du chemin fourni
$backupPath     = realpath($backupPath).'/';
// On récupère la taille de la base en octets
$databaseSize   = $db->getSize();
// On récupère l'espace disque disponible en octets
$freeDiscSpace  = disk_free_space($backupPath);
// Espace nécessaire à la sauvegarde
$requiredSpaceDisk = $databaseSize * $multiplier;

// Conversion des valeurs en Mo
$databaseSizeMB      = bytesToMegabytes($databaseSize);
$requiredSpaceDiskMB = bytesToMegabytes($requiredSpaceDisk);
$freeDiscSpaceMB     = bytesToMegabytes($freeDiscSpace);

// on vérifie que l'espace disponible est suffisant
if( $requiredSpaceDisk > $freeDiscSpace )
{
    // Infos application
    $date       = date("Y-m-d");
    $systemName = get_sys_global_parameters("system_name");
    $replyTo    = get_sys_global_parameters("mail_reply");

    // Message dans le démon
    $message = __T('A_PROCESS_BACKUP_DB_FAILED');
    $message .= '<br />' . __T('A_BACKUP_DATABASE_DISK_SPACE');
    $message .= '<br />' . __T('A_PROCESS_BACKUP_DB_DB_SIZE',$databaseSizeMB);
    $message .= '<br />' . __T('A_BACKUP_DATABASE_DISK_SPACE_DETAILS_NEEDED',$requiredSpaceDiskMB);
    $message .= '<br />' . __T('A_BACKUP_DATABASE_DISK_SPACE_DETAILS_AVAILABLE',$freeDiscSpaceMB);   
    displayInDemon($message,'alert',true);
    // Message dans le tracelog
    sys_log_ast("Critical", "Trending&Aggregation", $module, __T("A_BACKUP_DATABASE_DISK_SPACE"), "support_1", "");

    // Mails
    // On récupère tous les administrateurs
    $allAdmins = UserModel::getAdmins();
    // On ajoute le reply comme destinataire
    $allAdmins[]['user_mail'] = $replyTo;
    // on ajoute le support
    if($replyTo != EMAIL_SUPPORT) 
        $allAdmins[]['user_mail'] = 'support@astellia.com';
    // on prépare et on envoir les mails
    foreach ( $allAdmins as $CurrentAdmin )
    {
            $mail = new Mail();
            $mail->From($systemName.'<'.$replyTo.'>');
            $mail->ReplyTo($replyTo);
            $mail->To($CurrentAdmin['user_mail']);
            $mail->Subject(__T("A_BACKUP_DATABASE_DISK_SPACE").' '.$date);
            $mail->Body(__T("A_BACKUP_DATABASE_DISK_SPACE")."\n\n\t".
                    __T("A_BACKUP_DATABASE_DISK_SPACE_DETAILS_NEEDED",$requiredSpaceDiskMB)."\n".
                    "\t".__T("A_BACKUP_DATABASE_DISK_SPACE_DETAILS_AVAILABLE",$freeDiscSpaceMB).
                    "\n\nThis mail was autogenerated, please do not reply");
            $mail->Send();
            displayInDemon("<b>Mail sent to " . $CurrentAdmin['user_mail'] . "</b><br />","normal",true);
    }
}
else
{
    // On poursuit la sauvegarde
    displayInDemon(__T('A_PROCESS_BACKUP_DB_ENOUGH_SPACE',$freeDiscSpaceMB),"normal",true);

    // On ne lance la sauvegarde qu si AUCUN processus n'est en cours d'éxécution
    $runningProcesses = MasterModel::getRunningProcesses();
    if(count($runningProcesses) > 0)
    {
        displayInDemon(__T('A_PROCESS_BACKUP_DB_PROCESS_RUNNING'),"alert",true);
        return;
    }
    
    // 23/11/2011 ACS BZ 24815 correct to have a thread safe script: check the right to write with "is_writable" instead of creating a file 
    if (!is_writable($backupPath)) 
    {
        $message = __T('A_PROCESS_BACKUP_DB_FAILED')." ";
        $message .= __T('A_PROCESS_BACKUP_DB_CANNOT_WRITE',$backupPath);
        displayInDemon($message,"alert",true);
        sys_log_ast("Critical", "Trending&Aggregation", $module, $message, "support_1", "");
        return;
    }

    // Test de l'existance d'un backup précédent
    // 06/09/2013 GFS - Bug 35898 - [SUP][5.3.1][#NA][TELUS] : dump_processing.txt file blocks unknown process to run
    if (file_exists($backupPath . $backupFile))
    {
    	displayInDemon(__T('A_PROCESS_BACKUP_DB_EXISTS',$today),"normal",true);
    	return;
    }
    
    // 03/12/2010 NSE bz 19620
    // ecrit un fichier qui va permettre d'indiquer aux fichiers qui sont lancés via la cron que la sauvegarde
    // est encours et donc qu'il ne faut pas se lancer. Cela n'engendre pas de connection à la base. D'où pas de lock waiting à chaque lancement.
    $processFile    = REP_PHYSIQUE_NIVEAU_0.'png_file/dump_processing.txt';
    $processHandle  = @fopen($processFile, "w");
    
    // Test génération du fichier
    if(!$processHandle)
    {
        $message = __T('A_PROCESS_BACKUP_DB_FAILED')." ";
        $message .= __T('A_PROCESS_BACKUP_DB_PROCESS_FILE_KO',$processFile);
        sys_log_ast("Critical", "Trending&Aggregation", $module, $message, "support_1", "");
        displayInDemon($message,"alert",true);
        return;
    }

    // Affichage d'une confirmation et fermeture du fichier
    displayInDemon(__T('A_PROCESS_BACKUP_DB_PROCESS_FILE_OK',$processFile),"normal",true);
    fclose($processHandle);
    
    //
    // Execution de la sauvegarde
    $command = "env PGPASSWORD={$APass} ".PSQL_DIR."/pg_dump -U {$AUser} -Z 6 {$DBName} > {$backupPath}{$backupFile} 2>/tmp/err";
    exec($command, $output, $return);
    // Test du résultat d'éxécution
    if($return == 0) {
    	sys_log_ast("Info", "Trending&Aggregation", $module, __T('A_PROCESS_BACKUP_DB_SUCCESS'), "support_1", "");
        displayInDemon(__T('A_PROCESS_BACKUP_DB_SUCCESS'),"normal",true);
	}
    else {
    	sys_log_ast("Critical", "Trending&Aggregation", $module, __T('A_PROCESS_BACKUP_DB_FAILED'), "support_1", "");
        displayInDemon(__T('A_PROCESS_BACKUP_DB_FAILED').'<br />'.implode("\n",$output).(file_exists('/tmp/err') ? file_get_contents('/tmp/err') : ''),'alert',true);
        unlink($backupPath . $backupFile);
	}

    // 2012/09/07 NSE bz 28787 : la suppression du fichier ne doit être effectuée que si la sauvegarde est terminée
    // pour celà, on vérifie si le fichier de dump est encore en train de grossir ou non
    $tailleBackupA = filesize($backupPath.$backupFile);
    // on lui laisse le temps de grossir un peu
    sleep(10);
    // on vide le cache de la fonction filesize()
    clearstatcache();
    $tailleBackupB = filesize($backupPath.$backupFile);
    if ($tailleBackupB > $tailleBackupA){
        // s'il grossit encore, on ne fait rien, une vérification sera à nouveau effectuée dans 30 minutes (lancement de la cron)
        sys_log_ast("Info", "Trending&Aggregation", $module, __T('A_PROCESS_BACKUP_DB_RUNNING',bytesToMegabytes($tailleBackupB).'Mo'), "support_1", "");
        displayInDemon(__T('A_PROCESS_BACKUP_DB_PROCESS_FILE_NOT_DELETED').": ".__T('A_PROCESS_BACKUP_DB_RUNNING',bytesToMegabytes($tailleBackupB).'Mo'),'normal',true);
    }
    else{
        // Suppression du fichier dump processing et controle de suppression
        $deletionMessage = __T('A_PROCESS_BACKUP_DB_PROCESS_FILE_DELETED',$processFile);
        $deletionStatus = 'normal';
        if (!@unlink($processFile)) 
        {
            $deletionStatus = 'alert';
            $deletionMessage = __T('A_PROCESS_BACKUP_DB_PROCESS_FILE_NOT_DELETED',$processFile);
            sys_log_ast("Critical", "Trending&Aggregation", $module, $deletionMessage, "support_1", "");
        }

	// 03/10/2012 ACS BZ 29105 display of warning during backup processus
	// remove the lock of the dump warning.
	$db->execute("UPDATE sys_global_parameters SET value = '0' WHERE parameters = 'lock_dump_warning'");

        displayInDemon($deletionMessage,$deletionStatus,true);
    }
}
?>
